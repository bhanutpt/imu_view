

# Program to communicate with a device that communicates with ChekrAppLink protocol using BLE.

# Import packages required for BLE communications.
import asyncio
from bleak import BleakScanner, BleakClient

# Import packages for handling base64 encoding.
import base64

# Import packages for handling os interaction.
import os
import sys

# Import packages required for time.
import time

# Import packages required for ChekrAppLink protocol.
import calv5.tx as tx
import calv5.rx as rx
import calv5.rx_parser as rx_parser

# Inputs to Program:
MAC_ADDR = "C1:5B:85:40:61:A9" #"D8:F1:91:8F:2B:0C" #"C1:5B:85:40:61:A9" #"D8:F1:91:8F:2B:0C" #
REC_DURATION = 25
output_filename = "t21_04.bin"


# Device MAC Address and UUIDs.
# UUIDs are from the ChekrAppLink protocol.
mac_addr = MAC_ADDR
service_uuid = "0000fff0-0000-1000-8000-00805f9b34fb"
tx_uuid = "6765a69d-cd79-4df6-aad5-043df9425556"
rx_uuid = "b6ab2ce3-a5aa-436a-817a-cc13a45aab76"
notify_uuid = "207bdc30-c3cc-4a14-8b66-56ba8a826640"

# Define the global frame counter at the module level
frame_counter = 0

# Function to scan for BLE devices.
async def ble_scan(duration):
    devices = await BleakScanner.discover(timeout=duration)
    for device in devices:
        print(device)

# Function to connect to the BLE device.
async def ble_connect(mac_addr):
    client = BleakClient(mac_addr)
    await client.connect()
    print(f"Connected: {client.is_connected}")
    return client

# Function to disconnect from the BLE device.
async def ble_disconnect(client):
    if client:
        await client.disconnect()
        print("Disconnected")

# Notification handler callback function
def notification_handler(sender, data):
    global frame_counter
    frame_counter += 1

    # Convert the raw data to a base64 encoded string
    b64_data = base64.b64encode(data).decode('utf-8')
    
    # Append the base64 string to the file with a newline separator.
    with open(output_filename, "a") as file:
        file.write(b64_data + "\n")
    
    # Optionally, log at the console that the frame has been recorded.
    print(f"Frame {frame_counter}")

# Function to connect with the BLE device, send MAC Address command and print response.
async def start_ble_live(duration):
    client = await ble_connect(mac_addr)

    # Set the epoch time on the device
    print("\nCMD: Set Epoch Time")
    epoch_time_pc = int(time.time() * 1000)
    print(f"Epoch Time: {epoch_time_pc}")
    data = epoch_time_pc.to_bytes(8, byteorder='big')
    tx_frame = tx.set_epoch_time_frame(data)
    print(f"Data: {' '.join(f'{byte:02x}' for byte in tx_frame)}")

    # Send the frame and read the response
    await client.write_gatt_char(tx_uuid, tx_frame)
    await asyncio.sleep(0.1)
    response = await client.read_gatt_char(rx_uuid)
    print(f"Response: {' '.join(f'{byte:02x}' for byte in response)}")

    # Get the epoch time from the device
    print("\nCMD: Get Epoch Time")
    data = bytes.fromhex('00')
    tx_frame = tx.get_epoch_time_frame(data)
    print(f"Data: {' '.join(f'{byte:02x}' for byte in tx_frame)}")

    # Send the frame and read the response
    await client.write_gatt_char(tx_uuid, tx_frame)
    await asyncio.sleep(0.1)
    response = await client.read_gatt_char(rx_uuid)
    print(f"Response: {' '.join(f'{byte:02x}' for byte in response)}")

    # Parse the response
    parsed_frame = rx_parser.parse_rx_frame(response)
    epoch_time_dev = parsed_frame[0][0]
    print(f"Epoch Time (Dev): {epoch_time_dev}")

    # Print time difference between device and PC
    td = epoch_time_dev - epoch_time_pc
    print(f"Time Difference: {td}")

    # Check if the time difference is less then 200ms, else disconnect and exit function
    if td >= 200:
        print("Time sync difference is above threshold.") 
        await ble_disconnect(client)
        return

    # Start BLE live raw IMU recording session.
    print("\nCMD: Start BLE Live Recording Session")
    data = bytes.fromhex('01')  # Start recording session
    tx_frame = tx.start_stop_ble_live_raw_imu_rec_frame(data)
    print(f"Data: {' '.join(f'{byte:02x}' for byte in tx_frame)}")

    # Send the frame and read the response
    await client.write_gatt_char(tx_uuid, tx_frame)
    await asyncio.sleep(0.1)
    response = await client.read_gatt_char(rx_uuid)
    print(f"Response: {' '.join(f'{byte:02x}' for byte in response)}")

    # Register for notifications to read data that the device broadcasts.
    await client.start_notify(notify_uuid, notification_handler)
    print("Notification handler registered. Listening for notifications...")

    # Wait for the specified duration during which notifications will be received.
    await asyncio.sleep(duration)

    # Stop notifications.
    await client.stop_notify(notify_uuid)
    print("Notification handler unregistered.")

    # Stop BLE live raw IMU recording session.
    print("\nCMD: Stop BLE Live Recording Session")
    data = bytes.fromhex('00')  # Stop recording session
    tx_frame = tx.start_stop_ble_live_raw_imu_rec_frame(data)
    print(f"Data: {' '.join(f'{byte:02x}' for byte in tx_frame)}")

    # Send the frame and read the response
    await client.write_gatt_char(tx_uuid, tx_frame)
    await asyncio.sleep(0.1)
    response = await client.read_gatt_char(rx_uuid)
    print(f"Response: {' '.join(f'{byte:02x}' for byte in response)}")
    
    # Disconnect from the BLE device.
    await ble_disconnect(client)

# Test Get MAC Address Command.
asyncio.run(start_ble_live(REC_DURATION))
